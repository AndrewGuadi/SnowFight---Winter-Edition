<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snowbrawl: World War (Online)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        :root { --btn-scale: 1; }
        body { 
            margin: 0; overflow: hidden; background-color: #e3f2fd; 
            touch-action: none; font-family: 'Segoe UI', Tahoma, sans-serif; 
            user-select: none; -webkit-user-select: none; 
        }
        canvas { display: block; }
        
        /* UI Elements - Copied from All-Controls */
        .glass-panel { background: rgba(255, 255, 255, 0.15); backdrop-filter: blur(8px); border: 1px solid rgba(255, 255, 255, 0.4); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); }
        .control-btn { background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.6); backdrop-filter: blur(4px); border-radius: 50%; position: relative; pointer-events: auto; }
        .control-btn:active, .control-btn.active { transform: scale(0.92); background: rgba(255, 255, 255, 0.4); }
        
        #joystick-zone { position: absolute; bottom: 30px; left: 30px; width: 140px; height: 140px; z-index: 10; pointer-events: auto; transform-origin: bottom left; transform: scale(var(--btn-scale)); }
        #action-zone { position: absolute; bottom: 30px; right: 30px; display: flex; flex-direction: column; align-items: center; gap: 15px; z-index: 10; transform-origin: bottom right; transform: scale(var(--btn-scale)); }
        
        .animate-pop { animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes popIn { 0% { transform: scale(0.5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Start Screen / Connect Screen -->
    <div id="start-screen" class="absolute inset-0 bg-slate-900/90 backdrop-blur-md flex flex-col items-center justify-center z-50">
        <div class="bg-white/95 p-8 rounded-3xl shadow-2xl text-center max-w-lg w-full mx-4 border border-white/50 animate-pop">
            <h1 class="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-cyan-400 mb-2">SNOWBRAWL</h1>
            <p class="text-slate-500 font-bold mb-6 tracking-widest text-xs uppercase">Multiplayer Edition</p>
            
            <div id="connection-status" class="mb-6 flex flex-col items-center">
                <div class="animate-spin h-8 w-8 border-4 border-blue-500 rounded-full border-t-transparent mb-2"></div>
                <p class="text-sm font-bold text-slate-400">CONNECTING TO SERVER...</p>
            </div>

            <button id="btn-play" onclick="joinGame()" disabled class="w-full bg-slate-300 text-white font-black text-xl py-4 rounded-xl shadow-lg transition-all transform scale-95 opacity-50 cursor-not-allowed">
                WAITING FOR SERVER...
            </button>
        </div>
    </div>

    <!-- UI Overlay (HUD) -->
    <div id="ui-layer" class="hidden absolute inset-0 pointer-events-none flex flex-col justify-between p-4 overflow-hidden z-40">
        <div class="flex justify-between items-start w-full pointer-events-auto">
            <div class="glass-panel text-blue-600 px-5 py-2 rounded-xl flex flex-col items-center min-w-[80px] transform skew-x-[-10deg]">
                <span class="text-[10px] uppercase font-black opacity-70 skew-x-[10deg]">Blue</span>
                <span id="score-blue" class="text-3xl font-black skew-x-[10deg]">0</span>
            </div>
            <div class="glass-panel text-red-600 px-5 py-2 rounded-xl flex flex-col items-center min-w-[80px] transform skew-x-[-10deg]">
                <span class="text-[10px] uppercase font-black opacity-70 skew-x-[10deg]">Red</span>
                <span id="score-red" class="text-3xl font-black skew-x-[10deg]">0</span>
            </div>
        </div>
    </div>

    <!-- Controls Layer -->
    <div id="controls-layer" class="hidden absolute inset-0 z-30 overflow-hidden pointer-events-none">
        <div id="joystick-zone">
            <div class="w-full h-full rounded-full border-2 border-white/30 bg-gradient-to-br from-white/10 to-transparent relative backdrop-blur-sm shadow-xl">
                <div id="joystick-knob" class="absolute w-12 h-12 bg-white rounded-full shadow-lg top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 border border-slate-200"></div>
            </div>
        </div>

        <div id="action-zone">
            <div class="flex gap-4 items-end">
                <!-- Dash -->
                <div id="btn-dash" class="control-btn w-16 h-16 flex items-center justify-center bg-yellow-400/80 active:bg-yellow-500 shadow-lg">
                    <svg class="h-8 w-8 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-width="2.5" d="M13 5l7 7-7 7M5 5l7 7-7 7" /></svg>
                </div>
                <!-- Throw -->
                <div id="btn-throw" class="control-btn w-24 h-24 flex items-center justify-center bg-gradient-to-br from-red-500 to-red-600 active:from-red-600 shadow-xl">
                    <svg class="h-10 w-10 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-width="2.5" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064" /></svg>
                    <svg class="absolute inset-0 w-full h-full rotate-[-90deg] pointer-events-none" viewBox="0 0 100 100">
                        <circle cx="50" cy="50" r="46" fill="none" stroke="rgba(255,255,255,0.3)" stroke-width="4" />
                        <circle id="charge-indicator" cx="50" cy="50" r="46" fill="none" stroke="white" stroke-width="4" stroke-dasharray="289" stroke-dashoffset="289" style="transition: stroke-dashoffset 0.1s linear;" />
                    </svg>
                </div>
            </div>
            <!-- Gather -->
            <div id="btn-gather" class="control-btn w-16 h-16 flex items-center justify-center bg-blue-500/80 mt-2 shadow-lg active:bg-blue-600">
                <svg class="h-8 w-8 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-width="2.5" d="M7 11.5V14m0-2.5v-6a1.5 1.5 0 113 0m-3 6a1.5 1.5 0 00-3 0v2a7.5 7.5 0 0015 0v-5a1.5 1.5 0 00-3 0m-6-3V11m0-5.5v-1a1.5 1.5 0 013 0v1m0 0V11" /></svg>
            </div>
        </div>
    </div>

<script>
/**
 * --- CONFIGURATION ---
 * REPLACE WITH YOUR RENDER.COM URL
 */
const SERVER_URL = "http://localhost:3000"; 
// Example: const SERVER_URL = "https://snowbrawl-backend.onrender.com";

const socket = io(SERVER_URL);
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

const CONFIG = {
    viewportWidth: window.innerWidth,
    viewportHeight: window.innerHeight,
    cameraLerp: 0.1,
    screenShake: 0
};

// Client State
const STATE = {
    id: null,
    worldWidth: 2000,
    worldHeight: 2000,
    camera: { x: 0, y: 0 },
    players: {}, // VisualPlayer instances
    obstacles: [],
    snowballs: [],
    particles: [],
    popups: [],
    footprints: [],
    inputs: { moveX: 0, moveY: 0, angle: 0, dash: false, gather: false, throwStart: false, throwRelease: false }
};

/**
 * --- AUDIO ENGINE (From all-controls.html) ---
 */
const Audio = {
    ctx: null,
    init: function() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    playTone: function(freq, type, duration, vol, slideTo = null) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if (slideTo) osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + duration);
    },
    playNoise: function(duration, vol) {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        noise.connect(gain); gain.connect(this.ctx.destination);
        noise.start();
    },
    sfx: {
        throw: () => { Audio.playNoise(0.1, 0.2); Audio.playTone(400, 'triangle', 0.1, 0.2, 100); },
        hit: () => { Audio.playNoise(0.2, 0.5); Audio.playTone(100, 'square', 0.1, 0.4, 50); },
        dash: () => { Audio.playNoise(0.3, 0.2); Audio.playTone(300, 'sine', 0.3, 0.3, 800); },
        collect: () => Audio.playTone(600, 'sine', 0.1, 0.1, 800),
        ui: () => Audio.playTone(1200, 'sine', 0.05, 0.1)
    }
};

/**
 * --- VISUAL CLASSES ---
 */
class VisualPlayer {
    constructor(data) {
        this.id = data.id;
        this.team = data.team;
        // Interpolation props
        this.x = data.x;
        this.y = data.y;
        this.targetX = data.x;
        this.targetY = data.y;
        
        // Cosmetics from server
        this.skinColor = data.skinColor || '#ffdbac';
        this.hatType = data.hatType || 0;
        this.teamColor = this.team === 'blue' ? '#2196F3' : '#F44336';
        this.teamColorDark = this.team === 'blue' ? '#1976D2' : '#D32F2F';

        // Anim
        this.facingAngle = 0;
        this.walkCycle = 0;
        this.flashTimer = 0;
    }

    update(serverData) {
        this.targetX = serverData.x;
        this.targetY = serverData.y;
        this.isFrozen = serverData.isFrozen;
        this.hasBall = serverData.hasBall;
        this.chargeLevel = serverData.chargeLevel;
        this.gatherProgress = serverData.gatherProgress;

        // Smooth Interpolation
        this.x += (this.targetX - this.x) * 0.25;
        this.y += (this.targetY - this.y) * 0.25;

        // Walk Cycle Calculation
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        const speed = Math.hypot(dx, dy);
        
        if (speed > 1) {
            this.facingAngle = Math.atan2(dy, dx);
            this.walkCycle += 0.2 + (speed * 0.05);
            // Local Footprints
            if (Math.random() < 0.1) {
                STATE.footprints.push({x: this.x, y: this.y + 10, life: 200, angle: this.facingAngle});
            }
        } else {
            this.walkCycle = 0;
        }
        
        if (this.flashTimer > 0) this.flashTimer--;
    }

    draw(camX, camY) {
        const drawX = this.x - camX;
        const drawY = this.y - camY;
        const bob = Math.sin(this.walkCycle * 2) * 2;
        const scale = this.gatherProgress > 0 ? 0.9 : 1;

        if (this.flashTimer > 0) { ctx.globalCompositeOperation = 'source-over'; ctx.fillStyle = '#FFF'; }

        ctx.save();
        ctx.translate(drawX, drawY + bob);
        ctx.scale(scale, scale);

        if (this.isFrozen) {
            ctx.fillStyle = 'rgba(179, 229, 252, 0.6)';
            ctx.fillRect(-16, -24, 32, 40);
            ctx.strokeStyle = '#FFF'; ctx.strokeRect(-16, -24, 32, 40);
            ctx.fillStyle = this.teamColor; ctx.beginPath(); ctx.arc(0, -10, 10, 0, Math.PI*2); ctx.fill();
        } else {
            // Legs
            const legOffset = Math.sin(this.walkCycle) * 6;
            ctx.fillStyle = '#333'; 
            ctx.beginPath(); ctx.arc(-6, 8 + legOffset, 4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(6, 8 - legOffset, 4, 0, Math.PI*2); ctx.fill();

            // Body
            ctx.fillStyle = this.teamColor;
            ctx.beginPath(); ctx.roundRect(-12, -10, 24, 20, 8); ctx.fill();
            ctx.fillStyle = this.teamColorDark; ctx.fillRect(-2, -10, 4, 20);

            // Head
            ctx.fillStyle = this.skinColor;
            ctx.beginPath(); ctx.arc(0, -16, 9, 0, Math.PI*2); ctx.fill();

            // Hat Logic
            if (this.hatType === 1) { 
                ctx.fillStyle = this.teamColorDark; ctx.beginPath(); ctx.arc(0, -20, 9, Math.PI, 0); ctx.fill(); ctx.beginPath(); ctx.arc(0, -24, 3, 0, Math.PI*2); ctx.fill();
            } else if (this.hatType === 2) { 
                ctx.strokeStyle = '#555'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, -16, 9.5, Math.PI, 0); ctx.stroke();
                ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.arc(-9, -16, 4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(9, -16, 4, 0, Math.PI*2); ctx.fill();
            } else if (this.hatType === 3) {
                 ctx.strokeStyle = this.teamColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, -16, 10, 0, Math.PI*2); ctx.stroke();
            }

            // Eyes & Hands
            const eyeOffX = Math.cos(this.facingAngle) * 3;
            const eyeOffY = Math.sin(this.facingAngle) * 3;
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(-2 + eyeOffX, -16 + eyeOffY, 1.5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(2 + eyeOffX, -16 + eyeOffY, 1.5, 0, Math.PI*2); ctx.fill();

            const hx = Math.cos(this.facingAngle) * 10;
            const hy = Math.sin(this.facingAngle) * 10;
            
            if (this.hasBall) {
                ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.arc(hx, hy - 2, 5, 0, Math.PI*2); ctx.fill();
                if (this.chargeLevel > 0) {
                    ctx.strokeStyle = `rgba(255,255,255,${this.chargeLevel/60})`;
                    ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(hx, hy-2, 8, 0, Math.PI*2); ctx.stroke();
                }
            } else {
                 ctx.fillStyle = this.teamColorDark; ctx.beginPath(); ctx.arc(-10, 0, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(10, 0, 3, 0, Math.PI*2); ctx.fill();
            }
        }
        ctx.restore();

        // Self Indicator
        if (this.id === STATE.id) {
            ctx.fillStyle = '#FFD700';
            ctx.beginPath(); ctx.moveTo(drawX - 5, drawY - 45); ctx.lineTo(drawX + 5, drawY - 45); ctx.lineTo(drawX, drawY - 38); ctx.fill();
        }
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random() - 0.5) * 4;
        this.vy = (Math.random() - 0.5) * 4;
        this.life = 1.0;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life -= 0.05; }
    draw(cx, cy) {
        if (this.life <= 0) return;
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x - cx, this.y - cy, 3, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Popup {
    constructor(x, y, text, color) {
        this.x = x; this.y = y; this.text = text; this.color = color;
        this.life = 60; this.vy = -1;
    }
    update() { this.y += this.vy; this.life--; }
    draw(cx, cy) {
        ctx.globalAlpha = Math.min(1, this.life / 20);
        ctx.fillStyle = this.color; ctx.font = 'bold 16px Arial';
        ctx.shadowColor = 'black'; ctx.shadowBlur = 2;
        ctx.fillText(this.text, this.x - cx, this.y - cy);
        ctx.shadowBlur = 0; ctx.globalAlpha = 1;
    }
}

function createParticles(x, y, color, count) {
    for(let i=0; i<count; i++) STATE.particles.push(new Particle(x, y, color));
}

function addPopup(x, y, text, color) {
    STATE.popups.push(new Popup(x, y, text, color));
}

/**
 * --- SOCKET & NETWORK ---
 */
socket.on('connect', () => {
    // Update UI to show "Ready"
    const statusDiv = document.getElementById('connection-status');
    const btn = document.getElementById('btn-play');
    statusDiv.innerHTML = '<p class="text-green-500 font-bold">CONNECTED!</p>';
    btn.disabled = false;
    btn.classList.remove('bg-slate-300', 'opacity-50', 'cursor-not-allowed');
    btn.classList.add('bg-blue-600', 'hover:bg-blue-500', 'cursor-pointer', 'transform', 'hover:scale-105');
    btn.innerText = "JOIN BATTLE";
});

socket.on('init', (data) => {
    STATE.id = data.id;
    STATE.worldWidth = data.width;
    STATE.worldHeight = data.height;
    STATE.obstacles = data.obstacles;
});

socket.on('state', (serverData) => {
    // Sync Players
    for (let id in serverData.players) {
        const pData = serverData.players[id];
        if (!STATE.players[id]) {
            STATE.players[id] = new VisualPlayer(pData); // New
        }
        STATE.players[id].update(pData); // Update
    }
    // Remove disconnected
    for (let id in STATE.players) {
        if (!serverData.players[id]) delete STATE.players[id];
    }
    
    STATE.snowballs = serverData.snowballs;

    // Update Scores
    const blues = Object.values(serverData.players).filter(p => p.team === 'blue' && !p.isFrozen).length;
    const reds = Object.values(serverData.players).filter(p => p.team === 'red' && !p.isFrozen).length;
    document.getElementById('score-blue').innerText = blues;
    document.getElementById('score-red').innerText = reds;
});

// Effects triggered by server
socket.on('effect', (data) => {
    if (data.type === 'dash') {
        createParticles(data.x, data.y, '#FFF', 5);
        if (Math.hypot(STATE.camera.x - data.x, STATE.camera.y - data.y) < 800) Audio.sfx.dash();
    }
    else if (data.type === 'reload') {
        addPopup(data.x, data.y - 20, "RELOAD", "#FFF");
        if (data.id === STATE.id) Audio.sfx.collect();
    }
    else if (data.type === 'throw') {
        if (Math.hypot(STATE.camera.x - data.x, STATE.camera.y - data.y) < 800) Audio.sfx.throw();
    }
});

socket.on('hit', (data) => {
    createParticles(data.x, data.y, '#FFF', 15);
    Audio.sfx.hit();
    if (STATE.players[data.id]) {
        STATE.players[data.id].flashTimer = 10;
        addPopup(data.x, data.y, "HIT!", "#FFFF00");
    }
    if (data.id === STATE.id) {
        CONFIG.screenShake = 10;
        addPopup(data.x, data.y, "FROZEN!", "#00FFFF");
    }
});

/**
 * --- GAME LOOP ---
 */
function joinGame() {
    Audio.init();
    Audio.sfx.ui();
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('ui-layer').classList.remove('hidden');
    document.getElementById('controls-layer').classList.remove('hidden');
}

function gameLoop() {
    requestAnimationFrame(gameLoop);
    
    // --- SEND INPUT ---
    if (STATE.id) {
        socket.emit('input', {
            moveX: STATE.inputs.moveX,
            moveY: STATE.inputs.moveY,
            dash: STATE.inputs.dash,
            gather: STATE.inputs.gather,
            throwStart: STATE.inputs.throwStart,
            throwRelease: STATE.inputs.throwRelease,
            angle: STATE.inputs.angle
        });
        
        // Reset single-frame triggers
        STATE.inputs.throwStart = false;
        STATE.inputs.throwRelease = false;
        STATE.inputs.dash = false;
        STATE.inputs.gather = false;
    }

    // --- CAMERA ---
    let shakeX = 0, shakeY = 0;
    if (CONFIG.screenShake > 0) {
        shakeX = (Math.random() - 0.5) * CONFIG.screenShake;
        shakeY = (Math.random() - 0.5) * CONFIG.screenShake;
        CONFIG.screenShake *= 0.9;
    }

    const myPlayer = STATE.players[STATE.id];
    if (myPlayer) {
        let tx = myPlayer.x - CONFIG.viewportWidth / 2;
        let ty = myPlayer.y - CONFIG.viewportHeight / 2;
        tx = Math.max(0, Math.min(tx, STATE.worldWidth - CONFIG.viewportWidth));
        ty = Math.max(0, Math.min(ty, STATE.worldHeight - CONFIG.viewportHeight));
        STATE.camera.x += (tx - STATE.camera.x) * CONFIG.cameraLerp;
        STATE.camera.y += (ty - STATE.camera.y) * CONFIG.cameraLerp;
    }

    const cx = STATE.camera.x + shakeX;
    const cy = STATE.camera.y + shakeY;

    // --- RENDER ---
    ctx.clearRect(0, 0, CONFIG.viewportWidth, CONFIG.viewportHeight);

    // Grid
    ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = 2; ctx.beginPath();
    const gridSize = 100;
    const offX = -cx % gridSize; const offY = -cy % gridSize;
    for(let x=offX; x<CONFIG.viewportWidth; x+=gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, CONFIG.viewportHeight); }
    for(let y=offY; y<CONFIG.viewportHeight; y+=gridSize) { ctx.moveTo(0, y); ctx.lineTo(CONFIG.viewportWidth, y); }
    ctx.stroke();

    // Border
    ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 5;
    ctx.strokeRect(0 - cx, 0 - cy, STATE.worldWidth, STATE.worldHeight);

    // Footprints
    for(let i=STATE.footprints.length-1; i>=0; i--) {
        const fp = STATE.footprints[i];
        fp.life--;
        if(fp.life <= 0) { STATE.footprints.splice(i,1); continue; }
        if (fp.x < cx || fp.x > cx+CONFIG.viewportWidth) continue;
        ctx.save(); ctx.translate(fp.x - cx, fp.y - cy); ctx.rotate(fp.angle);
        ctx.fillStyle = `rgba(255,255,255,${fp.life/200})`;
        ctx.beginPath(); ctx.ellipse(0, -3, 3, 2, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(0, 3, 3, 2, 0, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }

    // Objects
    STATE.obstacles.forEach(obs => {
        if (obs.x + obs.radius < cx || obs.x - obs.radius > cx + CONFIG.viewportWidth) return;
        const dx = obs.x - cx; const dy = obs.y - cy;
        ctx.fillStyle = 'rgba(0,0,30,0.15)'; ctx.beginPath(); ctx.ellipse(dx, dy + obs.radius/2, obs.radius, obs.radius*0.4, 0, 0, Math.PI*2); ctx.fill();
        
        if (obs.type === 'tree') {
            ctx.fillStyle = '#1e4620'; ctx.beginPath(); ctx.moveTo(dx, dy-55); ctx.lineTo(dx+25, dy+10); ctx.lineTo(dx-25, dy+10); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.moveTo(dx, dy-55); ctx.lineTo(dx+8, dy-40); ctx.lineTo(dx-8, dy-40); ctx.fill();
        } else if (obs.type === 'snowman') {
            ctx.fillStyle = '#f0f9ff'; ctx.beginPath(); ctx.arc(dx, dy, 16, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(dx, dy-20, 12, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.arc(dx, dy-22, 2, 0, Math.PI*2); ctx.fill();
        } else {
             ctx.fillStyle = '#78909c'; ctx.beginPath(); ctx.arc(dx, dy, 20, 0, Math.PI*2); ctx.fill();
        }
    });

    // Players
    const renderList = Object.values(STATE.players).sort((a,b) => a.y - b.y);
    renderList.forEach(p => p.draw(cx, cy));

    // Snowballs
    STATE.snowballs.forEach(b => {
        const dx = b.x - cx; const dy = b.y - cy - b.z;
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.arc(b.x - cx, b.y - cy, b.radius, 0, Math.PI*2); ctx.fill(); 
        ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.arc(dx, dy, b.radius, 0, Math.PI*2); ctx.fill();
    });

    // Particles/Popups
    STATE.particles.forEach((p, i) => { p.update(); p.draw(cx, cy); if(p.life<=0) STATE.particles.splice(i,1); });
    STATE.popups.forEach((p, i) => { p.update(); p.draw(cx, cy); if(p.life<=0) STATE.popups.splice(i,1); });
}

/**
 * --- INPUTS ---
 */
function resize() { CONFIG.viewportWidth = window.innerWidth; CONFIG.viewportHeight = window.innerHeight; canvas.width = CONFIG.viewportWidth; canvas.height = CONFIG.viewportHeight; }
window.addEventListener('resize', resize);
resize();

// Joystick
const joyZone = document.getElementById('joystick-zone');
const joyKnob = document.getElementById('joystick-knob');
let joyActive = false;
let joyOrigin = {x:0, y:0};

const handleJoy = (e, isEnd) => {
    if(isEnd) { joyActive = false; joyKnob.style.transform = `translate(-50%, -50%)`; STATE.inputs.moveX=0; STATE.inputs.moveY=0; return; }
    const t = e.changedTouches ? e.changedTouches[0] : e;
    if (!joyActive) {
        const rect = joyZone.getBoundingClientRect();
        joyOrigin = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
        joyActive = true;
    }
    let dx = t.clientX - joyOrigin.x; let dy = t.clientY - joyOrigin.y;
    const dist = Math.hypot(dx, dy); const max = 35;
    if (dist > max) { dx = (dx/dist)*max; dy = (dy/dist)*max; }
    joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    STATE.inputs.moveX = dx/max; STATE.inputs.moveY = dy/max;
    // Update Angle based on movement
    if (dist > 5) STATE.inputs.angle = Math.atan2(STATE.inputs.moveY, STATE.inputs.moveX);
};
joyZone.addEventListener('touchstart', (e)=>{e.preventDefault(); handleJoy(e, false)});
joyZone.addEventListener('touchmove', (e)=>{e.preventDefault(); handleJoy(e, false)});
joyZone.addEventListener('touchend', (e)=>{e.preventDefault(); handleJoy(e, true)});

// Buttons
const btnDash = document.getElementById('btn-dash');
const btnThrow = document.getElementById('btn-throw');
const btnGather = document.getElementById('btn-gather');

btnDash.addEventListener('touchstart', (e)=>{e.preventDefault(); STATE.inputs.dash = true;});
btnThrow.addEventListener('touchstart', (e)=>{e.preventDefault(); STATE.inputs.throwStart = true;});
btnThrow.addEventListener('touchend', (e)=>{e.preventDefault(); STATE.inputs.throwRelease = true;});
btnGather.addEventListener('touchstart', (e)=>{e.preventDefault(); STATE.inputs.gather = true;});
btnGather.addEventListener('touchend', (e)=>{e.preventDefault(); STATE.inputs.gather = false;});

// Keyboard
window.addEventListener('keydown', (e)=>{
    const k = e.key.toLowerCase();
    if(k==='w') STATE.inputs.moveY = -1;
    if(k==='s') STATE.inputs.moveY = 1;
    if(k==='a') STATE.inputs.moveX = -1;
    if(k==='d') STATE.inputs.moveX = 1;
    if(k===' ') STATE.inputs.dash = true;
    if(k==='f') STATE.inputs.throwStart = true;
    if(k==='g') STATE.inputs.gather = true;
});
window.addEventListener('keyup', (e)=>{
    const k = e.key.toLowerCase();
    if(k==='w'||k==='s') STATE.inputs.moveY = 0;
    if(k==='a'||k==='d') STATE.inputs.moveX = 0;
    if(k===' ') STATE.inputs.dash = false;
    if(k==='f') STATE.inputs.throwRelease = true;
    if(k==='g') STATE.inputs.gather = false;
});

// Mouse Aim
window.addEventListener('mousemove', (e) => {
    const p = STATE.players[STATE.id];
    if(p) STATE.inputs.angle = Math.atan2(e.clientY - (p.y - STATE.camera.y), e.clientX - (p.x - STATE.camera.x));
});
window.addEventListener('mousedown', (e) => {
    if (e.button === 0) STATE.inputs.throwStart = true;
    if (e.button === 2) STATE.inputs.gather = true;
});
window.addEventListener('mouseup', (e) => {
    if (e.button === 0) STATE.inputs.throwRelease = true;
    if (e.button === 2) STATE.inputs.gather = false;
});
window.addEventListener('contextmenu', e=>e.preventDefault());

gameLoop();
</script>
</body>
</html>
